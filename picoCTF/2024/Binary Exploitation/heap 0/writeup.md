# heap 0
- [heap 0](#heap-0)
  - [Summary](#summary)
  - [Walk-through](#walk-through)
  - [Exploit](#exploit)
  - [Flag](#flag)
  - [Mitigatons](#mitigations)
  - [Key Takeaways](#key-takeaways)

### Summary
_picoCTF 2024 : Binary Exploitation_ | 50pts (Easy)

This challange is about corrupting memory in the region of computer memory known as the **heap**. If a special variable on the heap can be modified, the flag is revealed. The player is provided with a way to write data to the heap, and there is no restriction to the amount of data written. The heap addresses are provided to the player to make it an easy first exposure to heap overflows.
This class of vulnerability is know as a **buffer overflow** which is when a program writes more data to a buffer than was originally allocated for that buffer causing adjacent memory to be overwritten.

### Walk-through
For this challange, we are provided with the source code, a compiled binary, and a runnable instance to which we can connect.
Upon connecting to the challange instance at ```nc tethys.picoctf.net 61422```, we are presentend with the following information
```console
Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5cfce84012b0  ->   pico
+-------------+----------------+
[*]   0x5cfce84012d0  ->   bico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

```

Option 4 looks promising, so let's look at the code to see where that option would take us.
Inside the `main()` function, we find this switch statment for the option choices.
```c
        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print safe_var
            printf("\n\nTake a look at my variable: safe_var = %s\n\n",
                   safe_var);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
```
Option 4 takes us to `check_win()`
```c
void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flage for you :(\n");
        fflush(stdout);
    }
}
```
In order to print the flag, we need to overwite the `safe_var` variable such that it contains something other than "bico".
The `safe_var` variable is allocated on the heap in `init()`.
```c
void init() {
    printf("\nWelcome to heap0!\n");
    printf(
        "I put my data on the heap so it should be safe from any tampering.\n");
    printf("Since my data isn't on the stack I'll even let you write whatever "
           "info you want to the heap, I already took care of using malloc for "
           "you.\n\n");
    fflush(stdout);
    input_data = malloc(INPUT_DATA_SIZE);
    strncpy(input_data, "pico", INPUT_DATA_SIZE);
    safe_var = malloc(SAFE_VAR_SIZE);
    strncpy(safe_var, "bico", SAFE_VAR_SIZE);
}
```
Allocating memory on the heap is done using `malloc()`. The other variable allocated on the heap here is `input_data`. This is the variable that is displayed on connection to the challange by the `print_heap()` function.
```c
void print_heap() {
    printf("Heap State:\n");
    printf("+-------------+----------------+\n");
    printf("[*] Address   ->   Heap Data   \n");
    printf("+-------------+----------------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+----------------+\n");
    printf("[*]   %p  ->   %s\n", safe_var, safe_var);
    printf("+-------------+----------------+\n");
    fflush(stdout);
}
```
Option 2 in the menu takes us to `write_buffer` where user input is written to `input_data` via the `scanf()` function.
```c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
```
When `print_heap()` is called, either on entry or by Option 1, we see the heap addresses of both the `input_data` and `safe_var` variables.
The address for `input_data` is lower than that of `safe_var`, which on the heap means that the data populated at the pointer to `input_var` move towards the memory address of `safe_var`.
If we subtract 0x5cfce84012b0 from 0x5cfce84012d0, we get 0x20 (32 bytes) between pointers.
Therefore, if we provide more than 32 byes of data to write to the heap via Option 2, we should begin to overwite the data of `safe_var` and pass the `strcmp()` check in `check_win()` to get the flag.
### Exploit
1. Upon connecting, we will double check that the variables are still 32 bytes apart on the heap.
1. Select Option 2 to Write to buffer
1. We'll manually enter the input, using the last hex digit to keep count `0123456789abcdef0123456789abcdefP`. This should put "P" into `safe_var`
1. Verify the variables were overwritten by using Option 1.
1. Use Option 4 to print the flag.

### Flag
<details>
  <summary>Click to reveal the flag</summary>
picoCTF{my_first_heap_overflow_749119de}
</details>

### Mitigations
The vulnerability exploited here was the lack of input size restriction in the`scanf()` function in `write_buffer()`.
```c
scanf("%s", input_data);
```
The `input_data` variable is allocated on the heap with a size of 5 as specified by the symbolic constant (a global and unchangeable variable) `INPUT_DATA_SIZE`
```c
// amount of memory allocated for input_data
#define INPUT_DATA_SIZE 5
```
```c
input_data = malloc(INPUT_DATA_SIZE);
```
Therefore, the maximum allowable size of the input written to `input_data` should be 4, or 1 less than the size allocated, since `scanf()` will insert a trailing null character.
This can be achieved by modifying the format string passed to `scanf()`.
```c
scanf("%4s", input_data);
```
By doing so, we restrict the amount of data written to the location of `input_data`, ensuring there is not an overflow.

### Key Takeaways
- It is important to remember that memory addresses on the **heap** get larger (low to high), whereas addresses on the **stack** get smaller (hight to low)
